# application project makefile

SHELL          = /bin/bash
CFG           ?= .env
PRG           ?= $(shell basename $$PWD)

# -----------------------------------------------------------------------------
# Build config

GO            ?= go
VERSION       ?= $(shell git describe --tags --always)
SOURCES       ?= cmd/*/*.go *.go

# -----------------------------------------------------------------------------
# Runtime data

# Site host
APP_SITE      ?= $(PRG).dev.lan

APP_LISTEN    ?= :8080

# -----------------------------------------------------------------------------
# docker part

APP_IMAGE  ?= $(PRG)

# image prefix
PROJECT_NAME ?= $(PRG)

# dcape net
DCAPE_NET    ?= dcape_default

# docker-compose image
DC_VER ?= 1.23.2

# -----------------------------------------------------------------------------
# dcape part

# dcape containers name prefix
DCAPE_PROJECT_NAME ?= dcape

define CONFIG_DEFAULT
# ------------------------------------------------------------------------------
# application config file, generated by make $(CFG)

# Site host
APP_SITE=$(APP_SITE)

# App/Docker listen addr
APP_LISTEN=$(APP_LISTEN)

# Docker image tag
APP_IMAGE=$(APP_IMAGE)

# dcape net
DCAPE_NET=$(DCAPE_NET)

endef
export CONFIG_DEFAULT

# ------------------------------------------------------------------------------

-include $(CFG)
export

.PHONY: all api dep build run lint test up up-db down psql clean help

all: help

build: dep ## Build the binary file for server
	@go build -v -ldflags "-X main.version=`git describe --tags`" ./cmd/$(PRG)/

## Build app used in docker from scratch
#build-standalone: cov vet lint lint-more

build-standalone:
	CGO_ENABLED=0 GOOS=linux go build -ldflags "-X main.version=`git describe --tags`" -a ./cmd/$(PRG)/

run: ## Build and run binary
	$(GO) run -ldflags "-X main.version=$(VERSION)" ./cmd/$(PRG)/ --listen ${APP_LISTEN}

lint: ## Run linter
	@golangci-lint run ./...

# ------------------------------------------------------------------------------
# Docker

start-hook: up

up: ## Start app container
up: CMD=up -d app
up: dc

up-db: ## Start pg container only
up-db: CMD=up -d db
up-db: dc

up-all: ## Start pg & app containers
up-all: CMD=up -d
up-all: dc

down: ## Stop containers and remove them
down: CMD=rm -f -s
down: dc

# $$PWD используется для того, чтобы текущий каталог был доступен 
# в контейнере docker-compose по тому же пути
# и относительные тома новых контейнеров могли его использовать
dc: docker-compose.yml ## Run docker-compose (make dc CMD=build)
	@docker run --rm  \
	  -v /var/run/docker.sock:/var/run/docker.sock \
	  -v $$PWD:$$PWD \
	  -w $$PWD \
	  docker/compose:$(DC_VER) \
	  -p $$PROJECT_NAME \
	  $(CMD)

# ------------------------------------------------------------------------------

$(CFG):
	@[ -f $@ ] || { echo "$$CONFIG_DEFAULT" > $@ ; echo "Warning: Created default $@" ; }

conf: ## Create initial config
	@true

clean: ## Remove previous builds
	@rm -f $(PRG)

help: ## Display this help screen
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' Makefile | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-15s\033[0m %s\n", $$1, $$2}'
